package main // import "github.com/kpettijohn/guestinfo-network"

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os/exec"
	"strings"
	"text/template"
)

/*
Example guestinfo.metadata JSON
{
  "hostname": "myhost",
  "gateway": "10.10.10.1",
  "ipaddr": "10.10.10.100",
  "netmask": "255.255.255.0",
  "bootproto": "none"
}
*/

// NetworkConfig contains the overall network configuration gathered from VMware guestinfo
type NetworkConfig struct {
	IPAddr                 string `json:"ipaddr"`
	Gateway                string `json:"gateway"`
	Netmask                string `json:"netmask"`
	Hostname               string `json:"hostname"`
	BootProto              string `json:"bootproto"`
	GuestInfoMissing       bool
	GuestInfoEncodedOutput string
	GuestInfoDecodedOutput string
}

// StaticIPTemplate provides a static IP ENI template
const StaticIPTemplate = `# Generated by guestinfo-network
DEVICE=eth0
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
IPADDR={{.IPAddr}}
GATEWAY={{.Gateway}}
NETMASK={{.Netmask}}
NM_CONTROLLED=no
`

// DhcpTemplate provides a DHCP IP ENI template
const DhcpTemplate = `# Generated by guestinfo-network
DEVICE=eth0
TYPE=Ethernet
BOOTPROTO=dhcp
ONBOOT=yes
NM_CONTROLLED=no
`

// VMware tools is used to "get" the guestinfo.metadata key's value. If no key is found we fallback to DHCP (DhcpTemplate)
func (n *NetworkConfig) getGuestInfo() error {
	out, err := exec.Command("vmtoolsd", "--cmd", "info-get guestinfo.metadata").CombinedOutput()
	if err != nil {
		if strings.TrimRight(string(out), "\n") == "No value found" {
			n.GuestInfoMissing = true
		} else {
			return err
		}
	}
	// guestinfo.metadata is expected to be gzip+base64 JSON
	n.GuestInfoEncodedOutput = string(out)
	return nil
}

// Decode guestinfo.metadata (gzip+base64)
func (n *NetworkConfig) decodeGuestInfo() error {
	decoded, err := base64.StdEncoding.DecodeString(n.GuestInfoEncodedOutput)
	if err != nil {
		return err
	}
	decompressed, err := gzip.NewReader(bytes.NewReader(decoded))
	if err != nil {
		return err
	}
	result, err := ioutil.ReadAll(decompressed)
	if err != nil {
		return err
	}
	n.GuestInfoDecodedOutput = string(result)
	return nil
}

func main() {
	var networkTemplate bytes.Buffer
	network := &NetworkConfig{}
	err := network.getGuestInfo()
	if err != nil {
		fmt.Printf("# Error retreaving the guestinfo.metadata with vmtoolsd: %s\n", err)
	}
	if network.GuestInfoMissing {
		// Fallback to DHCP if guestinfo.metadata is not found
		tmpl := template.Must(template.New("network").Parse(DhcpTemplate))
		err = tmpl.Execute(&networkTemplate, network)
		if err != nil {
			fmt.Printf("# Error executing DHCP ENI template: %s\n", err)
		}
	} else {
		err = network.decodeGuestInfo()
		if err != nil {
			fmt.Printf("# Error attempting decode guestinfo: %s\n", err.Error())
		}
		err = json.Unmarshal([]byte(network.GuestInfoDecodedOutput), &network)
		if err != nil {
			fmt.Printf("# Error attempting unmarshal guestinfo JSON data: %s\n", err.Error())
		}
		if network.BootProto == "none" {
			tmpl := template.Must(template.New("network").Parse(StaticIPTemplate))
			err = tmpl.Execute(&networkTemplate, network)
			if err != nil {
				fmt.Printf("# Error executing static ENI template: %s\n", err)
			}
		} else {
			tmpl := template.Must(template.New("network").Parse(DhcpTemplate))
			err = tmpl.Execute(&networkTemplate, network)
			if err != nil {
				fmt.Printf("# Error executing DHCP ENI template: %s\n", err)
			}
		}
	}
	fmt.Printf("%s", networkTemplate.String())
}
